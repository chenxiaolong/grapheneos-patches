From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrew Gunnerson <accounts+github@chiller3.com>
Date: Wed, 22 Jan 2025 23:41:08 -0500
Subject: [PATCH 1/3] gmscompat: Add support for Device Health Services

This adds support for installing com.google.android.apps.turbo as a user
app. It is given access only to the system permissions necessary for the
adaptive brightness functionality to work:

* ACCESS_AMBIENT_LIGHT_STATS
* BRIGHTNESS_SLIDER_USAGE
* CONFIGURE_DISPLAY_BRIGHTNESS

The remaining permissions, aside from PACKAGE_USAGE_STATS and
RECEIVE_BOOT_COMPLETED, are removed during package parsing. The app
happens to be well compartmentalized, so all activities, providers,
receivers, and services unrelated to the adaptive brightness feature are
disabled during package parsing.

This initial implementation makes other packages invisible to the app,
so fetching phenotype flags from GMS is not supported. This means that
it is using the default MonotonicGaussianOfflineModel ML model instead
of the TFLiteSplineOfflineModel ML model that seems to be widely used on
the stock Pixel OS.
---
 core/java/android/ext/PackageId.java          |   3 +
 .../sysservice/GmcPackageManager.java         |   6 +
 .../pm/pkg/component/ParsedActivityUtils.java |   6 +
 .../pm/pkg/component/ParsedProviderUtils.java |   2 +
 .../pm/pkg/parsing/PackageParsingHooks.java   |  11 ++
 .../pm/ext/DeviceHealthServicesHooks.java     | 170 ++++++++++++++++++
 .../android/server/pm/ext/PackageExtInit.java |   2 +
 .../server/pm/ext/PackageHooksRegistry.java   |   2 +
 8 files changed, 202 insertions(+)
 create mode 100644 services/core/java/com/android/server/pm/ext/DeviceHealthServicesHooks.java

diff --git a/core/java/android/ext/PackageId.java b/core/java/android/ext/PackageId.java
index 2784ba86b84e..47ad2a2f0f29 100644
--- a/core/java/android/ext/PackageId.java
+++ b/core/java/android/ext/PackageId.java
@@ -56,4 +56,7 @@ public interface PackageId {
     /** @hide */ int BUGLE = 14;
 
     /** @hide */ String SYSTEM_KEYBOARD = "com.android.inputmethod.latin";
+
+    /** @hide */ String DEVICE_HEALTH_SERVICES_NAME = "com.google.android.apps.turbo";
+    /** @hide */ int DEVICE_HEALTH_SERVICES = 101;
 }
diff --git a/core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java b/core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java
index 3fe16a1a21a4..9a91d4e6a63a 100644
--- a/core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java
+++ b/core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java
@@ -20,6 +20,7 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.app.ActivityThread;
+import android.app.AppGlobals;
 import android.app.Application;
 import android.app.ApplicationPackageManager;
 import android.app.compat.gms.GmsCompat;
@@ -120,6 +121,11 @@ public class GmcPackageManager extends ApplicationPackageManager {
             if (GmsCompat.isGmsCore() || GmsCompat.isClientOfGmsCore(ai)) {
                 ai.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
             }
+        } else if (PackageId.DEVICE_HEALTH_SERVICES_NAME.equals(packageName) &&
+                AppGlobals.getInitialPackageId() == PackageId.DEVICE_HEALTH_SERVICES) {
+            // Spoof self as system app or else the adaptive brightness logic gets disabled.
+            // Checked by: com.google.android.libraries.smartbattery.common.util.PackageUtil
+            ai.flags |= ApplicationInfo.FLAG_SYSTEM;
         }
 
         if (!ai.enabled) {
diff --git a/core/java/com/android/internal/pm/pkg/component/ParsedActivityUtils.java b/core/java/com/android/internal/pm/pkg/component/ParsedActivityUtils.java
index 8d5f93b939bd..f4cdb71ae4ae 100644
--- a/core/java/com/android/internal/pm/pkg/component/ParsedActivityUtils.java
+++ b/core/java/com/android/internal/pm/pkg/component/ParsedActivityUtils.java
@@ -509,6 +509,12 @@ public class ParsedActivityUtils {
             activity.setExported(hasIntentFilters);
         }
 
+        if (isReceiver) {
+            pkg.getPackageParsingHooks().amendParsedReceiver(activity);
+        } else {
+            pkg.getPackageParsingHooks().amendParsedActivity(activity);
+        }
+
         return input.success(activity);
     }
 
diff --git a/core/java/com/android/internal/pm/pkg/component/ParsedProviderUtils.java b/core/java/com/android/internal/pm/pkg/component/ParsedProviderUtils.java
index 2b2efd67f078..118795475e6f 100644
--- a/core/java/com/android/internal/pm/pkg/component/ParsedProviderUtils.java
+++ b/core/java/com/android/internal/pm/pkg/component/ParsedProviderUtils.java
@@ -160,6 +160,8 @@ public class ParsedProviderUtils {
         }
         provider.setAuthority(authority);
 
+        pkg.getPackageParsingHooks().amendParsedProvider(provider);
+
         return parseProviderTags(pkg, tag, res, parser, visibleToEphemeral, provider, input);
     }
 
diff --git a/core/java/com/android/internal/pm/pkg/parsing/PackageParsingHooks.java b/core/java/com/android/internal/pm/pkg/parsing/PackageParsingHooks.java
index c1ade9ac4d8f..5acefda73fba 100644
--- a/core/java/com/android/internal/pm/pkg/parsing/PackageParsingHooks.java
+++ b/core/java/com/android/internal/pm/pkg/parsing/PackageParsingHooks.java
@@ -3,8 +3,10 @@ package com.android.internal.pm.pkg.parsing;
 import android.annotation.Nullable;
 import android.content.pm.PackageManager;
 
+import com.android.internal.pm.pkg.component.ParsedActivityImpl;
 import com.android.internal.pm.pkg.component.ParsedPermission;
 import com.android.internal.pm.pkg.component.ParsedProvider;
+import com.android.internal.pm.pkg.component.ParsedProviderImpl;
 import com.android.internal.pm.pkg.component.ParsedService;
 import com.android.internal.pm.pkg.component.ParsedServiceImpl;
 import com.android.internal.pm.pkg.component.ParsedUsesPermission;
@@ -43,6 +45,15 @@ public class PackageParsingHooks {
         return res;
     }
 
+    public void amendParsedActivity(ParsedActivityImpl a) {
+    }
+
+    public void amendParsedProvider(ParsedProviderImpl p) {
+    }
+
+    public void amendParsedReceiver(ParsedActivityImpl r) {
+    }
+
     public void amendParsedService(ParsedServiceImpl s) {
 
     }
diff --git a/services/core/java/com/android/server/pm/ext/DeviceHealthServicesHooks.java b/services/core/java/com/android/server/pm/ext/DeviceHealthServicesHooks.java
new file mode 100644
index 000000000000..8264b976c808
--- /dev/null
+++ b/services/core/java/com/android/server/pm/ext/DeviceHealthServicesHooks.java
@@ -0,0 +1,170 @@
+package com.android.server.pm.ext;
+
+import android.Manifest;
+import android.ext.PackageId;
+
+import com.android.internal.gmscompat.GmsCompatApp;
+import com.android.internal.pm.pkg.component.ParsedActivityImpl;
+import com.android.internal.pm.pkg.component.ParsedProviderImpl;
+import com.android.internal.pm.pkg.component.ParsedServiceImpl;
+import com.android.internal.pm.pkg.component.ParsedUsesPermission;
+import com.android.internal.pm.pkg.parsing.PackageParsingHooks;
+import com.android.server.pm.pkg.PackageStateInternal;
+
+import java.util.List;
+
+public class DeviceHealthServicesHooks extends PackageHooks {
+    private static final String TAG = DeviceHealthServicesHooks.class.getSimpleName();
+
+    static class ParsingHooks extends PackageParsingHooks {
+        @Override
+        public boolean shouldSkipUsesPermission(ParsedUsesPermission p) {
+            // Only enable the permissions needed for adaptive brightness to work.
+            switch (p.getName()) {
+                case Manifest.permission.ACCESS_AMBIENT_LIGHT_STATS:
+                case Manifest.permission.BRIGHTNESS_SLIDER_USAGE:
+                case Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS:
+                case Manifest.permission.RECEIVE_BOOT_COMPLETED:
+                    return false;
+                default:
+                    return true;
+            }
+        }
+
+        @Override
+        public void amendParsedActivity(ParsedActivityImpl a) {
+            String name = a.getClassName();
+
+            if (!name.equals("com.google.android.apps.turbo.cleardata.ClearDataActivity") &&
+                    !name.equals("com.google.android.gms.common.api.GoogleApiActivity") &&
+                    !name.startsWith("com.google.android.libraries.smartbattery.brightness.")) {
+                a.setEnabled(false);
+            }
+        }
+
+        @Override
+        public void amendParsedProvider(ParsedProviderImpl p) {
+            String name = p.getClassName();
+
+            if (!name.equals("androidx.startup.InitializationProvider")) {
+                p.setEnabled(false);
+            }
+        }
+
+        @Override
+        public void amendParsedReceiver(ParsedActivityImpl r) {
+            String name = r.getClassName();
+
+            if (!name.startsWith("androidx.work.impl.") &&
+                    !name.startsWith("com.google.android.libraries.phenotype.") &&
+                    !name.startsWith("com.google.android.libraries.smartbattery.common.phenotype.") &&
+                    !name.startsWith("com.google.android.libraries.smartbattery.brightness.")) {
+                r.setEnabled(false);
+            }
+        }
+
+        @Override
+        public void amendParsedService(ParsedServiceImpl s) {
+            String name = s.getClassName();
+
+            if (!name.startsWith("androidx.work.impl.") &&
+                    !name.startsWith("com.google.android.libraries.phenotype.") &&
+                    !name.startsWith("com.google.android.libraries.smartbattery.common.phenotype.") &&
+                    !name.startsWith("com.google.android.libraries.smartbattery.brightness.")) {
+                s.setEnabled(false);
+            }
+        }
+    }
+
+    @Override
+    public int overridePermissionState(String permission, int userId) {
+        // These system permissions are required for adaptive brightness to work.
+        switch (permission) {
+            case Manifest.permission.ACCESS_AMBIENT_LIGHT_STATS:
+            case Manifest.permission.BRIGHTNESS_SLIDER_USAGE:
+            case Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS:
+                return PERMISSION_OVERRIDE_GRANT;
+            case Manifest.permission.RECEIVE_BOOT_COMPLETED:
+                return NO_PERMISSION_OVERRIDE;
+            default:
+                return PERMISSION_OVERRIDE_REVOKE;
+        }
+    }
+
+    @Override
+    public boolean shouldBlockPackageVisibility(int userId, PackageStateInternal otherPkg, boolean isSelfToOther) {
+        if (!isSelfToOther) {
+            return false;
+        }
+
+        // The actual adaptive brightness implementation is entirely self-contained and does not
+        // depend on GMS. This communication with GMS Core and Play Store is only allowed so that it
+        // can fetch phenotype feature flags, which enables the use of a better (bundled) ML model
+        // than the default. This access unfortunately also allows telemetry.
+        switch (otherPkg.getPackageName()) {
+            /*
+                W Turbo.UpdatePhenotypeFlagsJob: Daily P/H flag update running.
+                W Turbo.PhenotypeManager: Committing phenotype flags.
+                E ActivityThread: Failed to find provider info for app.grapheneos.gmscompat.RpcProvider
+                E GmsCompat/GCA: call to app.grapheneos.gmscompat.RpcProvider failed
+                E GmsCompat/GCA: java.lang.IllegalArgumentException: Unknown authority app.grapheneos.gmscompat.RpcProvider
+                E GmsCompat/GCA:         at android.content.ContentResolver.call(ContentResolver.java:2491)
+                E GmsCompat/GCA:         at com.android.internal.gmscompat.GmsCompatApp.callRpcProvider(GmsCompatApp.java:120)
+                E GmsCompat/GCA:         at com.android.internal.gmscompat.GmsCompatApp.getBinder(GmsCompatApp.java:133)
+                E GmsCompat/GCA:         at com.android.internal.gmscompat.GmsCompatApp.iClientOfGmsCore2Gca(GmsCompatApp.java:102)
+                E GmsCompat/GCA:         at com.android.internal.gmscompat.GmcBinderDefs.maybeGetBinderDef(GmcBinderDefs.java:58)
+                E GmsCompat/GCA:         at com.android.internal.gmscompat.GmcBinderDefs.maybeOverrideBinder(GmcBinderDefs.java:25)
+                E GmsCompat/GCA:         at com.android.internal.gmscompat.GmsHooks.maybeOverrideBinder(GmsHooks.java:734)
+                E GmsCompat/GCA:         at android.os.Parcel.readStrongBinder(Parcel.java:3363)
+                E GmsCompat/GCA:         at blm.y(PG:16)
+                E GmsCompat/GCA:         at anv.onTransact(PG:21)
+                E GmsCompat/GCA:         at android.os.Binder.execTransactInternal(Binder.java:1436)
+                E GmsCompat/GCA:         at android.os.Binder.execTransact(Binder.java:1375)
+                E GmsCompat/GCA:         at android.os.BinderProxy.transactNative(Native Method)
+                E GmsCompat/GCA:         at android.os.BinderProxy.transact(BinderProxy.java:598)
+                E GmsCompat/GCA:         at bku.p(PG:211)
+                E GmsCompat/GCA:         at bfk.run(PG:786)
+                E GmsCompat/GCA:         at android.os.Handler.handleCallback(Handler.java:991)
+                E GmsCompat/GCA:         at android.os.Handler.dispatchMessage(Handler.java:102)
+                E GmsCompat/GCA:         at android.os.Looper.loopOnce(Looper.java:232)
+                E GmsCompat/GCA:         at android.os.Looper.loop(Looper.java:317)
+                E GmsCompat/GCA:         at android.os.HandlerThread.run(HandlerThread.java:85)
+             */
+            case GmsCompatApp.PKG_NAME:
+            case GmsCompatApp.PKG_NAME + ".lib":
+            case PackageId.GMS_CORE_NAME:
+            /*
+                W Turbo.UpdatePhenotypeFlagsJob: Daily P/H flag update running.
+                W Turbo.PhenotypeManager: Committing phenotype flags.
+                W GooglePlayServicesUtil: com.google.android.apps.turbo requires the Google Play Store, but it is missing.
+                W GoogleApiManager: The service for bpc is not available: bhp{statusCode=SERVICE_INVALID, resolution=null, message=null}
+                W GooglePlayServicesUtil: com.google.android.apps.turbo requires the Google Play Store, but it is missing.
+                W GoogleApiManager: The service for bpc is not available: bhp{statusCode=SERVICE_INVALID, resolution=null, message=null}
+                E PhenotypeFlagCommitter: Retrieving snapshot for com.google.android.apps.internal.zebedee#com.google.android.apps.turbo failed
+                W Turbo.PhenotypeManager: Finished committing phenotype flags.
+                W GooglePlayServicesUtil: com.google.android.apps.turbo requires the Google Play Store, but it is missing.
+                W GoogleApiManager: The service for bpc is not available: bhp{statusCode=SERVICE_INVALID, resolution=null, message=null}
+                W GooglePlayServicesUtil: com.google.android.apps.turbo requires the Google Play Store, but it is missing.
+                W GoogleApiManager: The service for bpc is not available: bhp{statusCode=SERVICE_INVALID, resolution=null, message=null}
+                W MobStoreFlagStore: Unable to update local snapshot for com.google.android.libraries.performance.primes#com.google.android.apps.turbo, may result in stale flags.
+                W MobStoreFlagStore: java.util.concurrent.ExecutionException: coy: 17: 17: API: Phenotype.API is not available on this device. Connection failed with: bhp{statusCode=SERVICE_INVALID, resolution=null, message=null}
+                W MobStoreFlagStore:    at dsz.r(PG:21)
+                W MobStoreFlagStore:    at dsz.get(PG:3)
+                W MobStoreFlagStore:    at a.i(PG:2)
+                W MobStoreFlagStore:    at dol.z(PG:10)
+                W MobStoreFlagStore:    at cpw.c(PG:1)
+                W MobStoreFlagStore:    at cei.run(PG:270)
+                W MobStoreFlagStore:    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:487)
+                W MobStoreFlagStore:    at java.util.concurrent.FutureTask.run(FutureTask.java:264)
+                W MobStoreFlagStore:    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:347)
+                W MobStoreFlagStore:    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
+                W MobStoreFlagStore:    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
+                W MobStoreFlagStore:    at java.lang.Thread.run(Thread.java:1117)
+             */
+            case PackageId.PLAY_STORE_NAME:
+                return false;
+            default:
+                return true;
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/pm/ext/PackageExtInit.java b/services/core/java/com/android/server/pm/ext/PackageExtInit.java
index 256c3c815101..d42cdeae7fc9 100644
--- a/services/core/java/com/android/server/pm/ext/PackageExtInit.java
+++ b/services/core/java/com/android/server/pm/ext/PackageExtInit.java
@@ -102,6 +102,8 @@ public class PackageExtInit implements ParsingPackageUtils.PackageExtInitIface {
                     "295499d8d0e93b7ed64f90e8cddffc12e3be23d8806f54e05d1abf415c37f5ba");
             case BUGLE_NAME -> validate(BUGLE, 273168063L,
                     "f7e73d4edc2b7f55eecd3f898d3cca7da9cbbf51694eba14f816e2eccf015035");
+            case DEVICE_HEALTH_SERVICES_NAME -> validate(DEVICE_HEALTH_SERVICES, 10270607L,
+                    "c91e8c545ff5f8ba6371bd88ba19fc26841d9ba5f4aea47b8f381df2b4d1ea41");
 
             default -> PackageId.UNKNOWN;
         };
diff --git a/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java b/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java
index 2f37f0757654..6f8a61369be8 100644
--- a/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java
+++ b/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java
@@ -18,6 +18,7 @@ public class PackageHooksRegistry {
             case PackageId.G_EUICC_LPA_NAME -> new EuiccGoogleHooks.ParsingHooks();
             case PackageId.PIXEL_CAMERA_SERVICES_NAME -> new PixelCameraServicesHooks.ParsingHooks();
             case PackageId.PIXEL_HEALTH_NAME -> new PixelHealthHooks.ParsingHooks();
+            case PackageId.DEVICE_HEALTH_SERVICES_NAME -> new DeviceHealthServicesHooks.ParsingHooks();
             default -> PackageParsingHooks.DEFAULT;
         };
     }
@@ -31,6 +32,7 @@ public class PackageHooksRegistry {
             case PackageId.PIXEL_CAMERA_SERVICES -> new PixelCameraServicesHooks();
             case PackageId.PIXEL_HEALTH -> new PixelHealthHooks();
             case PackageId.GMS_CORE -> new GmsCoreHooks();
+            case PackageId.DEVICE_HEALTH_SERVICES -> new DeviceHealthServicesHooks();
             default -> PackageHooks.DEFAULT;
         };
     }
-- 
2.53.0

